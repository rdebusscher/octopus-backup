=== Calling MicroProfile Endpoint

Since v0.9.7.2, there is support for creating a JWT token compatible with MicroProfile JWT Auth specification and add it automatically to the Rest client.

==== Use case

When your application needs to call some micro-services protected with the MicroProfile JWT Auth specification (https://github.com/eclipse/microprofile-jwt-auth/files/1305001/microprofile-jwt-auth-spec-1.0.pdf) this module can create the JWT token automatically based on the information known by the _UserPrincipal_. Additional claims can be passed to it, by creating a CDI bean implementing the _JWTClaimsProvider_

==== Setup support creation JWT token

We need the following dependency in the project setup:

[source,xml]
----
    <dependency>
        <groupId>be.c4j.ee.security.octopus.authentication</groupId>
        <artifactId>mp-jwt-client</artifactId>
        <version>0.9.7.2</version>
    </dependency>

----

This Maven artefact contains the JAX-RS client which add the required header and the logic for the creation of the JWT token compatible with the MicroProfile JWT Auth Token.

==== Calling endpoint

Calling the endpoint with the JWT token added to the header, requires just the usage of the **be.c4j.ee.security.credentials.authentication.microprofile.jwt.client.rest.OctopusMPJWTUserRestClient** CDI bean.

[source,xml]
----
    @Inject
    private OctopusMPJWTUserRestClient restClient;

    public void callMicroProfile() {
        restClient.get("http://localhost:9090/hello", String.class));
    }
----

The class contains also other methods for the REST operations (like POST, PUT and DELETE) and overoaded methods to specify also the Key id which needs to be used for the signing (see also further on)

There are 2 configuration parameters required

.octopusConfig.properties
----
jwk.file=demo.jwk
jwt.token.issuer=https://server.example.com
----

The _jwk.file_ defines the location where the RSA keys can be found and the _jwt.token.issuer_ for the issuer claim. The list of claims and how their value is derived is in the following table

[options="header"]
|=======================
|Claim name | value
|alg | RS256
|kid | kid from method parameter or _jwt.token.issuer_ configuration parameter value.
|typ | JWT
|preferred_username | UserPrincipal#getUserName()
|upn | UserPrincipal#getEmail()
|groups | Information from AuthorizationInfo
|iss | _jwt.token.issuer_ configuration parameter value
|iat | System timestamp
|exp | System timestamp + number of seconds defined by configuration parameter _jwt.token.timeToLive_
|id^*^ | UserPrincipal#getId()
|externalId^*^ | UserPrincipal#getExternalId()
|name^*^ | UserPrincipal#getName()
|=======================
^*^ indicates custom claims by Octopus.

The groups claim is based on the authorization information provided by the developer with the _AuthorizationInfoBuilder_. This are the rules of the mapping which are performed

* addPermission(String) -> The String parameter value is _as is_ copied to the groups claim.
* addPermission(NamedPermission) -> The name of the permission (NamedPermission#name())
* addRole(NamedRole) -> The name of the role when it is not mapped to _Permissions_ by the _RolePermissionResolver_.

The procedure to find the RSA key for the signature (as defined by the parameter _jwk.file_) is as follows

. If keyId is specified within the parameter and is present in the key set, use that key.
. If only 1 key is present in the key set, use that key.
. If no key selected yet, throw **MissingKeyException**

You can write your own logic for the key selection by implemebting the interface **be.c4j.ee.security.credentials.authentication.microprofile.jwt.jwk.KeySelector** and define it as a CDI bean (_ApplicationScoped_ is most appropiate)

The interface has one method that the developer should implement in order to supply the required key

----
   RSAKey selectSecretKey(String keyId, String url);
----

The parameter keyId is the one which is supplied by the developer as the method parameter (the overloaded versions within class _OctopusMPJWTUserRestClient_) and the url is the URL of the endpoint which is called (in case you want to return a key dependencing on the server which is called.


The RSA keys can be generated by the helper program :

/examples/rest/jwt-util module; be.c4j.ee.security.jwt.JWKManagerRSA


When you run this program; it prints out 5 artifacts on the console:

x-api-key : This is an unique identification for your third party
Private JWK: a JWK file containing the private and public parts of an RSA key which can be used to sign the JWT token which they will send to your Rest endpoint.
Private pkss#8 PEM: A Base64 encoded version of the private key within pkss#8 format.
Public JWK: A JWK file containing the public part of the same RSA key which octopus will use the verify the signing part of the JWT token.
Public X509 PEM: A Base64 encoded version of the public key within X509 format.


==== Using System accounts

FIXME

=== Endpoints protected with MicroProfile JWT Auth

Since v0.9.7.2, Octopus has support for using the MicroProfile JWT defined token as authentorization and authentication source.

==== Use case

This feagure allows you to use Octopus based applications or micro-services within an environment where the authentication and authorization information is contained within a JWT token as specified by the MicroProfile JWT Auth specification.

==== Setup support using JWT token

We need the following dependency in the project setup:

[source,xml]
----
    <dependency>
        <groupId>be.c4j.ee.security.octopus.authentication</groupId>
        <artifactId>mp-jwt-server</artifactId>
        <version>0.9.7.2</version>
    </dependency>

----

This artefact contains the **mpUser** filter which takes the JWT token information and transform it into Octopus information.

==== Configuration

Within the _securedURLs.ini_ file we can define that a certain URL or set of URLs needs to be protected with the MicroProfile JWT token.

----
/data/** = noSessionCreation, mpUser
----

Or when adding the octopus-rest artifact, we can use the _userRest_ filter.

----
/data/** = userRest, mpUser
----

The following configuration needs to be done in the _octopusConfig.properties_

----
jwk.file=demo.jwk

mp.aud=MPServerApp
----

It defines the location where the RSA keys can be found for the verification of the singing and the expected _Audience_ claim value.

The groups claim is translated to Roles and Permissions as follows

* The name contains a colon (:), like demo:read:* -> A (WildCard)permission is created for the value.
* The name does not contain a colon, like group1 -> A permission is created for the value (just like the String permissions described here ??) and defined as a role. This role can be converted by a _RoleLookup_ or _RolePermissionResolver_ if defined.

