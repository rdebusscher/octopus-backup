[[customCheck]]

==== Introduction

There are situations where the permission name is not enough to determine if the user has permission to access a certain method.

In the case for example where you have different affiliates in your company and various permissions need to be specified in an affiliate specific way. Meaning that a user has access to one, several or all affiliates for a certain permission, say create contracts.

The usage of a Custom voter is not a real option since we need to be able to specify the affiliates the user can access within the permission itself.

An example can be found in the _CustomCheck_ project available under _examples/authorization_ directory.

==== Custom permission

The first step we need to do is to create a custom Permission which will hold the additional information. In the example, the *SpecialNamedPermission* is created for this purpose.

[source, java]
----
public class SpecialNamedPermission extends NamedDomainPermission {

    private MyCheckInfo myCheckInfo;
    private List<Long> partitions;

    public SpecialNamedPermission(String someName, String wildcardString, MyCheckInfo myCheckInfo, List<Long> partitions) {

    // ... rest of code skipped.
----

Since all custom permissions need to extend a _named permission_ we use the _NamedDomainPermission_ class as a basis and add an enum (indicating if affiliates are specified = BASIC) and a list of Long values representing the affiliates.

==== Custom annotation

A custom annotation needs to be created to be used on the method signatures so that the interceptor knows which security check needs to be executed.

The annotation is a regular annotation which needs to be indicated in the Octopus configuration file so that the Octopus recognized the annotation as such.

[source, java]
----
@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyCheck {

    String value();

    MyCheckInfo info() default MyCheckInfo.BASIC;
}
----

The value will indicate the named permission (as name like _demo_ or as a wildcard permission string _demo:read:*_, both are supported)

The config needs to be updated as follows for this example.

----
customCheck.class=be.c4j.demo.security.custom.MyCheck
----

==== Custom voter

A custom voter needs to be created which will implement the required logic. Since the logic is mainly based on a custom requirement, the developer needs to implement the logic himself.

However, the basic is the same as a custom voter, but there are some additional values available which can help in the implementation of the logic.

[source, java]
----
@Named
@ApplicationScoped
public class MyCheckAccessDecisionVoter extends AbstractGenericVoter {
    @Override
    protected void checkPermission(AccessDecisionVoterContext accessDecisionVoterContext, Set<SecurityViolation> violations) {

        InvocationContext invocationContext = accessDecisionVoterContext.getSource();
        AnnotationInfo annotationInfo = (AnnotationInfo) invocationContext.getContextData().get(AnnotationInfo.class.getName());
        List<Annotation> annotations = annotationInfo.getAnnotation(MyCheck.class);
        if (annotations.isEmpty()) {
            throw new IllegalArgumentException("Annotation @MyCheck not found on method but this Voter is called because it as found?");
        }

        Annotation annotation = annotations.get(0);  // Always the first one. When there are multiple ones, the first one is the one on the method level.

        // This is the permission the user corresponding to the contents of the value member.
        List<Permission> permissions = accessDecisionVoterContext.getMetaDataFor(Permission.class.getName(), List.class);

        if (permissions.isEmpty()) {
            violations.add(newSecurityViolation("Subject has not the required permission"));
        } else {
            SpecialNamedPermission specialNamedPermission = (SpecialNamedPermission) permissions.get(0);

----

This rather large code snippet needs some additional explanation.

* You must always extend fro the *AbstractGenericVoter* class
* It must be a *Named* CDI bean and the name must match the name generated by the *VoterNameFactory* for the custom check. See ???
* All the annotations (those of interest for Octopus) present on the method (or class) can be retrieved from *InvocationContext* instance (just like the _Method_ and _Class_ info)
* The *getAnnotation()* method retrieves the annotation instance, and the first one is the important one.
* The *AccessDecisionVoterContext* instance contains information about the permissions the user has in relation to the permission specified by the *value* member of the annotation (@MyCheck in the case of the example) +
   So when we specify _@MyCheck(value="demo:read:*", ..)_ it returns a list of permissions the user has which match this wildcard string (like _demo:read:*_, _demo:*:*_ and _*:*:*_)
* Depending on the permissions we have given the user, these can be regular permissions (like *NamedDomainPermission* instances) or instances of our special defined permissions as in the case of this example.

==== Specify Permissions for user

The assignment of the permission to a user happens just as always within the *getAuthorizationInfo()* method of the class implementing the *SecurityDataProvider* interface with the help of the *AuthorizationInfoBuilder*.

[source, java]
----
authorizationInfoBuilder.addPermission(new SpecialNamedPermission("demo", "demo:*:*", MyCheckInfo.BASIC, partitionList3));
----
